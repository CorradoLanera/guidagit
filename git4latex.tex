\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage[italian]{babel}

\usepackage{listings}
\usepackage{fourier}

\usepackage{color}
\usepackage{listings}
\usepackage{framed}

% \usepackage{tocloft}
% \renewcommand{\cftdot}{}
% 
% \usepackage{hyperref}

\begin{document}
\lstset{
  frame=single,
  breaklines = true, % per mandare a capo le righe troppo lunghe
  breakautoindent = true, % indenta le righe spezzate
  breakindent = 90pt, % indenta le righe di 30pt
%   language=bash,
%   showspaces=false,
%   showtabs=false,
}
\title{git4\LaTeX \\
  Una guida introduttiva a git per progetti \LaTeX}
\author{Pietro Giuffrida}
\maketitle

La presente guida si propone di presentare sinteticamente ed in modo spero non
troppo lacunoso l'uso che si può fare di git nel corso di un lavoro sviluppato
in \LaTeX\. Ritengo che git possa rappresentare un programma di estrema utilità
per mantenere in ordine le versioni progressivamente accumulate di uno o più
documenti. git permette infatti di gestire le versioni, il loro recupero o la
loro consultazione, il backup locale e remoto, tutto in estrema economia.

Usando esclusivamente linux, il terminale, kate come editor!

\tableofcontents

\section{Un semplice progetto \LaTeX}
Vogliamo sviluppare un documento con \LaTeX, utilizzando git come CVS.
Aperto un terminale, i passaggi indispensabili sono:
\begin{enumerate}
\item creiamo la cartella che conterrà i nostri sorgenti;
\item creiamo il primo file .tex;
\item inizializziamo la medesima directory come un repository git;
\item diciamo a git quali sono i file da \textit{tenere d'occhio},
aggiungendoli al repository.
\end{enumerate}

\begin{lstlisting}
$ mkdir nuovo_progetto
$ cd nuovo_progetto
$ touch np_main.tex
$ git init
$ git add .
$ git commit -am "Inizializzazione del nuovo progetto np"
\end{lstlisting}

Così facendo saremmo già pronti a lavorare con il nostro editor di fiducia, e
non resterebbe che eseguire un commit al termine di ogni modifica rilevante, in
modo da salvare cioè una determinata versione del progetto.

\begin{lstlisting}
$ commit -am "un ulteriore sviluppo del progetto"
\end{lstlisting}

\subsection{Aggiungere altri file al progetto}
Finora abbiamo eseguito il commit passando a git le due opzioni ``-am''. Con
l'opzione ``-m'' diciamo a git di utilizzare il testo virgolettato che segue il
comando come nota di versione del commit che stiamo eseguendo. Con l'opzione
``-a'' chiediamo a git di salvare tutte le modifiche apportate a tutti i file
che abbiamo precedentemente aggiunto al progetto.

Si presenta ora uno scenario tra i più comuni: dobbiamo aggiungere un ulteriore
file al progetto, per esempio un file .tex contenente un ulteriore capitolo, o
un file .bib contenente al bibliografia, o un qualsiasi altro file.
Quando eseguiamo il commit, potremmo aspettarci che git si accorga del nuovo
arrivato, ed in effetti dovrebbe restituire un messaggio di questo tipo:

\begin{lstlisting}
$ git commit -am "aggiunto file np_secondary.tex"
# On branch master
# Untracked files:
#   (use "git add <file>..." to include in what will be committed)
#
#       np_secondary.tex
nothing added to commit but untracked files present (use "git add" to track)
\end{lstlisting}

git si accorge quindi della presenza di un nuovo file, ma non lo aggiunge
automaticamente al progetto. D'altra parte, se avesse rilevato delle modifiche
ai file precedentemente aggiunti al progetto, non si sarebbe nemmeno curato di
comunicarci che il nuovo file non è ancora stato aggiunto al progetto.
Si potrebbe quindi scegliere di procedere in due modi: aggiungere
indiscriminatamente tutti i file della directory al progetto che stiamo
sviluppando; oppure aggiungere un singolo file.
Nel primo caso dovremmo ripetere il comando già usato in fase di
inizializzazione:

\begin{lstlisting}
$ git add.
\end{lstlisting}

Nel secondo caso aggiungiamo un singolo file:

\begin{lstlisting}
$ git add np_secondary.tex
\end{lstlisting}

Per quanto possa sembrare eccessivo, dato che accade con estrema frequenza di
dover aggiungere dei file ad un progetto, e che spesso si è fin troppo
distratti da quel che si sta scrivendo per occuparci di quel che fa git, credo
che sia preferibile aggiungere eseguire la prima delle due operazioni.

Dato però che nel corso dell'elaborazione di un testo inevitabilmente si
procederà alla generazione del documento in pdf mediante i vari comandi di
\LaTeX, si potrebbe determinare un controsenso. Se infatti eseguiamo il comando
``git add .'' dopo aver eseguito,
per esempio, pdflatex, evidentemente git aggiungerebbe al repository anche i
vari file di lavoro, dal pdf, ai file .log, .out e vari altri.
Per ovviare a questo inconveniente, è utile creare nella nostra directory di
lavoro un file denominato ``.gitignore''.

\begin{lstlisting}
$ touch .gitignore
$ echo "*.log" >> .gitignore
$ echo "*.pdf" >> .gitignore
$ echo "*.blg" >> .gitignore
$ echo "*.bbl" >> .gitignore
$ echo "*.aux" >> .gitignore
$ echo "*-blx.bib" >> .gitignore
$ echo "*.out" >> .gitignore
$ echo "*~" >> .gitignore
$ git add .gitignore
$ git commit -am "Aggiunto il file .gitignore"
\end{lstlisting}

Mediante questo file, diciamo a git che tutti i file con le estensioni in esso
definite non devono essere considerati appartenenti al progetto, e che non si
deve dar pena se non li aggiungiamo al repository.

\section{Consultazione dei log e ripristino di file}
Presi da una strano forma di pazzia abbiamo eliminato un file del nostro
progetto, ed abbiamo anche eseguito un commi masochistico.

\begin{lstlisting}
$ touch np_secondary.tex
$ echo "\subsection{sezione}" >> np_secondary.tex
$ git add .
$ git commit -am "Ho solo iniziato a lavorare"
$ rm np_secondary.tex
$ git commit -am "Ma ho gia' perso tutto"
\end{lstlisting}

Ora chiediamo conto a git della sua capacità di ripristinare una versione
precedentemente salvata.

\begin{lstlisting}
$ git log
commit 380228784f4095efdbce9d1d3408bcbdf01548cb
Author: Pietro Giuffrida <pietro.giuffri@gmail.com>
Date:   Sat Oct 2 18:58:44 2010 +0200

    Ma ho gia' perso tutto

commit c21d825df42f55ba127487fd93acf1c13c41b028
Author: Pietro Giuffrida <pietro.giuffri@gmail.com>
Date:   Sat Oct 2 18:55:07 2010 +0200

    Ho solo iniziato a lavorare

commit bef2662a93b8d57db934d2be69c290e8fcd282ae
Author: Pietro Giuffrida <pietro.giuffri@gmail.com>
Date:   Sat Oct 2 18:27:24 2010 +0200

    aggiunto file np_secondary.tex

commit 34e68a9db309081e67a693bf8153765298b73b10
Author: Pietro Giuffrida <pietro.giuffri@gmail.com>
Date:   Sat Oct 2 18:04:29 2010 +0200

    Inizializzazione del nuovo progetto np
\end{lstlisting}

Trattandosi di un file eliminato, non possiamo chiedere a git di stampare solo i
log relativi al singolo file. Dobbiamo quindi guardarli un pò di tutti, e
scegliere uno dei commit proposti. Nel nostro caso, l'eliminazione del file è
ben documentata dalla nota del commit, e quindi possiamo subito procedere a
verificare se il commit contiene una versione del file che stiamo cercando.

\begin{lstlisting}
$ git show c21d825df42f55ba127487fd93acf1c13c41b028
commit c21d825df42f55ba127487fd93acf1c13c41b028
Author: Pietro Giuffrida <pietro.giuffri@gmail.com>
Date:   Sat Oct 2 18:58:29 2010 +0200

    aggiunto file np_secondary.tex

diff --git a/np_secondary.tex b/np_secondary.tex
new file mode 100644
index 0000000..bfa5424
--- /dev/null
+++ b/np_secondary.tex
@@ -0,0 +1 @@
+pippo
\end{lstlisting}

Trovato il commit che contiene il file che intendiamo ripristinare, procediamo
a ricrearne una copia richiamandolo tramite l'index riportato da git con il
comando che abbiamo appena dato.

\begin{lstlisting}
$ git show bfa5424 > file_ripristinato
\end{lstlisting}

La procedura, con le complicazioni del caso, dovrebbe essere valida anche per
circostanze concrete. Vi consiglio comunque di fare delle prove simulando per
esempio commit di più file contenenti varie modifiche, per far pratica con gl
indici e la sintassi di git.
Possiamo ipotizzare in questo caso uno scenario di questo tipo:

\begin{lstlisting}
$ touch topolino pippo
$ echo qualcosa >> topolino
$ echo qualcosaltro >> pippo
$ git add.
$ git commit -am "creati e modificati topolino e pippo"
$ echo "ancora qualcosa" >> topolino
$ git commit -am "ulteriormente elaborato topolino"
$ git log topolino
commit 87548d4cd43cda917cf788866abd76f8399b639b
Author: Pietro Giuffrida <pietro.giuffri@gmail.com>
Date:   Sat Oct 2 19:27:23 2010 +0200

    ulteriormente elaborato topolino

commit f7a696e891bb81446f56adc996bc0a20a23ae9b5
Author: Pietro Giuffrida <pietro.giuffri@gmail.com>
Date:   Sat Oct 2 19:27:01 2010 +0200

    creati e modificati topolino e pippo
$ git show f7a696e891bb81446f56adc996bc0a20a23ae9b5
commit f7a696e891bb81446f56adc996bc0a20a23ae9b5
Author: Pietro Giuffrida <pietro.giuffri@gmail.com>
Date:   Sat Oct 2 19:27:01 2010 +0200

    creati e modificati topolino e pippo

diff --git a/pippo b/pippo
new file mode 100644
index 0000000..a09d8a1
--- /dev/null
+++ b/pippo
@@ -0,0 +1 @@
+qualcosa
diff --git a/topolino b/topolino
new file mode 100644
index 0000000..a09d8a1
--- /dev/null
+++ b/topolino
@@ -0,0 +1 @@
+qualcosaltro
$ git show a09d8a1 > topolino_ripristinato
\end{lstlisting}

\section{backup su usb}
\section{inotifywait e commit automatico}

\end{document}